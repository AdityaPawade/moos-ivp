# CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
PROJECT(IVP)

CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
if(COMMAND cmake_policy)
  cmake_policy(SET CMP0003 OLD)
  cmake_policy(SET CMP0005 OLD)
endif(COMMAND cmake_policy)

# Force -fPIC because gcc complains when we don't use it with x86_64 code.
# Note sure why: -fPIC should only be needed for shared objects, and
# AFAIK, CMake gets that right when building shared objects. -CJC
SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -g")

#===============================================================================
# FINDING MOOS' HEADERS AND LIBRARIES...
#===============================================================================

# *** REPLACE "../../MOOS" WITH WHATEVER VALUE IS REQUIRED.  THE DIRECTORY 
# *** SHOULD HAVE CHILD DIRECTORIES SUCH AS "Core", "Essentials", ETC.
SET(MOOS_BASE_DIR ../../MOOS)

# Using absolute pathnames seems to work better then relative, because you're 
# never sure from which directory a relative path will be employed in commands
# such as LINK_DIRECTORIES() ...
GET_FILENAME_COMPONENT(MOOS_BASE_DIR_ABSOLUTE ../../MOOS ABSOLUTE)

# Confirm that MOOS_BASE_DIR seems to be set to a valid value...
IF(NOT EXISTS ${MOOS_BASE_DIR_ABSOLUTE}/Core)
   MESSAGE(FATAL_ERROR 
      "The CMake variable MOOS_BASE_DIR_ABSOLUTE has the value "
      "'${MOOS_BASE_DIR_ABSOLUTE}'.\n\n"
      "That directory doesn't have a 'Core' subdirectory, which means it's "
      "definitely not the base directory of a MOOS source tree."
      "\n\n"
      "You need to set the CMake variable 'MOOS_BASE_DIR' to a different value."
)
ENDIF(NOT EXISTS ${MOOS_BASE_DIR_ABSOLUTE}/Core)

SET(MOOS_LIB_DIR ${MOOS_BASE_DIR_ABSOLUTE}/MOOSBin)
LINK_DIRECTORIES(${MOOS_LIB_DIR})

# No harm in giving all IvP software access to MOOS's include libraries.
SET(MOOS_INCLUDE_DIRS
   ${MOOS_BASE_DIR_ABSOLUTE}/Essentials
   ${MOOS_BASE_DIR_ABSOLUTE}/Core
   ${MOOS_BASE_DIR_ABSOLUTE}/Essentials/MOOSUtilityLib
   ${MOOS_BASE_DIR_ABSOLUTE}/Core/MOOSLIB
   ${MOOS_BASE_DIR_ABSOLUTE}/Core/MOOSGenLib
   )
INCLUDE_DIRECTORIES(${MOOS_INCLUDE_DIRS})
   
#===============================================================================
# BUILDING IvP...
#===============================================================================

#----------------------------------------------
# This was added by Andrew Shafer...
IF(CMAKE_COMPILER_IS_GNUCXX)
   SET( WALL_ON OFF CACHE BOOL "tell me about all compiler warnings (-Wall) ")
   IF(WALL_ON)
            SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
   ENDIF( WALL_ON)
ELSE(CMAKE_COMPILER_IS_GNUCXX)
   IF(MSVC)
            SET( WALL_ON OFF CACHE BOOL "tell me about all compiler warnings (-Wall) ")
            IF(WALL_ON)
               SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
               ENDIF(WALL_ON)
      ELSE(MSVC)
      # Other compilers go here      
      
      ENDIF(MSVC)
ENDIF(CMAKE_COMPILER_IS_GNUCXX)
#----------------------------------------------

# GET_FILENAME_COMPONENT(IVP_SRC_DIR_ABSOLUTE . ABSOLUTE)
#    ADD_DEFINITIONS(-DIVP_RELEASE_NAME="
# IF    ("${MOOS-IVP-RELEASE-NAME}" == "")
#    
# ELSE  ("${MOOS-IVP-RELEASE-NAME}" == "")
# ENDIF ("${MOOS-IVP-RELEASE-NAME}" == "")

# # Create a header file describing the svn revision of the source code being
# # built.  Try to judge whether or not the revision number might have changed
# # by seeing if the .svn/entries file has been updated.  It's not perfect, 
# # because it's possible that the user only updated part of the source tree and
# # left this particular .svn/entires file unchanged.  But a more rigorous check
# # would require a lot more code.
# ADD_CUSTOM_COMMAND(
#    OUTPUT ${IVP_SRC_DIR_ABSOLUTE}/svn_revision_number.h
#    COMMAND sh -c bin/write-version-file.sh
#    DEPENDS ${IVP_SRC_DIR_ABSOLUTE}/.svn/entries
#    )
# 
# # EXECUTE_PROCESS(
# #    COMMAND sh -c "svn info . | grep Revision | cut -d ' ' -f2"
# #    OUTPUT_VARIABLE SVN_REVISION_NUMBER
# #    OUTPUT_STRIP_TRAILING_WHITESPACE)
# #    
# # FILE(WRITE svn_revision_number.h 
# #    "#ifndef SVN_REVISION_NUMBER_HEADER\n"
# #    "#define SVN_REVISION_NUMBER_HEADER\n"
# #    "\n"
# #    "/* Note: This file generated by ivp/src/CMakeLists.txt */\n"
# #    "\n"
# #    "#define SVN_REVISION_NUMBER ${SVN_REVISION_NUMBER}\n"
# #    "\n"
# #    "#endif\n"
# #    )

# Tell CMake (and thus C++) where to find IvP's header files...
FILE(GLOB IVP_LIBRARY_DIRS lib_*)
INCLUDE_DIRECTORIES(${IVP_LIBRARY_DIRS})

# Set whether or not to build GUI utils
SET( BUILD_GUIS ON CACHE BOOL "Build GUI applications")


# This is used to supply a preprocessor definition that gets compiled into some
# code, such as lib_marineview.  I really dislike this approach because it's 
# very brittle w.r.t. anything getting moved around, or if you use the code on
# a different system than that on which it was compiled. -CJC
GET_FILENAME_COMPONENT(IVP_DATA_DIR ../data ABSOLUTE)

#---------------------------------------------------------------------
#  Build the Libraries
#---------------------------------------------------------------------
IF(BUILD_GUIS)
  SET(GUI_LIBS_TO_BUILD
    lib_ipfview
    lib_marineview
    lib_fltk-1.1.7
    )
ENDIF(BUILD_GUIS)

SET(IVP_LIBS_TO_BUILD
  lib_behaviors
  lib_behaviors-marine
  lib_bhvutil
  lib_genutil
  lib_geometry
  lib_helmivp
  lib_ivpbuild
  lib_ivpcore
  lib_logic
  lib_logutils
  lib_mbutil
  lib_navplot
  lib_avd
  lib_anrp_util
  lib_newmat10D
)

# As a matter of preference, each built IvP library file (.a) should be placed 
# in its source directory.
SET( LIBRARY_OUTPUT_PATH "" CACHE PATH "" FORCE )

FOREACH(L ${IVP_LIBS_TO_BUILD} ${GUI_LIBS_TO_BUILD} )
  ADD_SUBDIRECTORY(${L})
  # We're actually fighting the lib_fltk-1.1.7 CMake files for control over this
  # detail, so we have to reassert it after adding the FLTK subdirectory.
  SET( LIBRARY_OUTPUT_PATH "" CACHE PATH "" FORCE )
ENDFOREACH(L)

#---------------------------------------------------------------------
#  Build the Applications
#---------------------------------------------------------------------

if (${APPLE})
    set(LINUX_ONLY_APPS "")
else (${APPLE})
    #  Doesn't build on OS X 10.5
    SET(LINUX_ONLY_APPS "")
endif (${APPLE})


SET(IVP_APPS_TO_BUILD
  app_ffview
  app_geoview
  app_logview
  app_alogscan
  app_aloggrep
  app_alogrm
  app_alogclip
  app_splug
  app_domquery
  iMarineSim
  pDeployHandler
  pEchoVar
  pXRelay
  pHelmIvP
  pMarinePID
  pMarineViewer
  pShipsideViewer
  pTransponderAIS
  pViewerRelay
  uHelmScope
  uProcessWatch
  uRepeater
  uTermCommand
  uFunctionVis
  uXMS
  uPokeDB
  ${LINUX_ONLY_APPS}
)

FOREACH(A ${IVP_APPS_TO_BUILD})
  # Programs get placed in ivp/src/bin/
  SET( EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin CACHE PATH "" FORCE )
  ADD_SUBDIRECTORY(${A})
ENDFOREACH(A)


