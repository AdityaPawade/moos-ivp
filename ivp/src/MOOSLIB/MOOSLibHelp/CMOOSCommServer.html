<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  CMOOSCommServer</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.6">
</HEAD>
 <BODY>
<H1><img src="moose6.gif"> <center>MOOSLib Class Documentation</center></H1>
</BODY>

In file MOOSCommServer.h:<H2>class  <A HREF="#DOC.DOCU">CMOOSCommServer</A></H2></H2><BLOCKQUOTE>This class is the MOOS Comms Server.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CCMOOSCommObject,MCMOOSCommObject.html,CCMOOSCommServer,MCMOOSCommServer.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="up">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.4.1">SetOnRxCallBack</A></B>(bool (*pfn)(MOOSMSG_LIST &amp; MsgListRx, MOOSMSG_LIST &amp; MsgListTx, void*  pParam), void*  pParam)
<DD><I>Set the recieve message call back handler.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.4.2">SetOnDisconnectCallBack</A></B>(bool (*pfn)(string &amp; sClient, void*  pParam), void*  pParam)
<DD><I>Set the disconnect message call back handler.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.3">ListenLoop</A></B>()
<DD><I>This function is the listen loop called from one of the two server threads.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.4">ServerLoop</A></B>()
<DD><I>This function is the server loop called from one of the two server threads.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.5">Run</A></B>(long lPort)
<DD><I>Initialise the server.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.4.6">CMOOSCommServer</A></B>()
<DD><I>default constructor</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.4.7">~CMOOSCommServer</A></B>()
<DD><I>default destructor</I>
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif><!1><A HREF="CMOOSLock.html">CMOOSLock</A> <B><A HREF="#DOC.4.8">m_SocketListLock</A></B>
<DD><I>a simple mutex to guard access to m_ClientSocketList </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.4.15">m_nTotalActions</A></B>
<DD><I>internal count of the number of calls processed</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>HANDLE <B><A HREF="#DOC.4.17">m_hListenThread</A></B>
<DD><I>Win32 handle to Listen thread  </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>HANDLE <B><A HREF="#DOC.4.18">m_hServerThread</A></B>
<DD><I>Win32 handle to Server thread  </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned long <B><A HREF="#DOC.4.19">m_nListenThreadID</A></B>
<DD><I>ID of Listen Thread</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>unsigned long <B><A HREF="#DOC.4.20">m_nServerThreadID</A></B>
<DD><I>ID of Server Thread</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void* <B><A HREF="#DOC.4.22">m_pRxCallBackParam</A></B>
<DD><I>place holder for teh address of the object passed back to the user during an Rx callback </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void* <B><A HREF="#DOC.4.24">m_pDisconnectCallBackParam</A></B>
<DD><I>place holder for teh address of the object passed back to the user during a Disconnect callback </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>XPCTcpSocket* <B><A HREF="#DOC.4.25">m_pListenSocket</A></B>
<DD><I>Listen socket (bound to port address supplied in constructor) </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>XPCTcpSocket* <B><A HREF="#DOC.4.26">m_pFocusSocket</A></B>
<DD><I>pointer to the socket which server is currently processing call from </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>SOCKETLIST <B><A HREF="#DOC.4.27">m_ClientSocketList</A></B>
<DD><I>list of all currently connected sockets </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>SOCKETFD_2_CLIENT_NAME_MAP <B><A HREF="#DOC.4.28">m_Socket2ClientMap</A></B>
<DD><I>map of socket file descriptors to the string name of the client process at teh other end</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>long <B><A HREF="#DOC.4.31">m_lListenPort</A></B>
<DD><I>port listen socket is bound to </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.32">m_bQuit</A></B>
<DD><I>threads continue while this flag is false</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.4.33">m_nMaxSocketFD</A></B>
<DD><I>largest FD of all connected sockets</I>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>int <B><A HREF="#DOC.4.9">GetMaxSocketFD</A></B>()
<DD><I>figures out what the largest socket FD of all connected sockets.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.4.10">DoBanner</A></B>()
<DD><I>prints class information banner to cout </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>string <B><A HREF="#DOC.4.11">GetClientName</A></B>(XPCTcpSocket* pSocket)
<DD><I>Get the name of the client on the remote end of pSocket</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>void <B><A HREF="#DOC.4.12">PoisonClient</A></B>(XPCTcpSocket* pSocket, char*  sReason)
<DD><I>Send a Poisoned mesasge to the client on the end of pSocket.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.13">HandShake</A></B>(XPCTcpSocket* pNewSocket)
<DD><I>Perform handshaling with client just after a connection has been accepted </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.14">IsUniqueName</A></B>(string &amp; sClientName)
<DD><I>returns true if a server has no connection to the named client </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.16">OnClientDisconnect</A></B>()
<DD><I>called when a client disconnects or and error occurs</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.21">(*m_pfnRxCallBack)</A></B>(MOOSMSG_LIST &amp; MsgListRx, MOOSMSG_LIST &amp; MsgListTx, void*  pCaller)
<DD><I>user supplied OnRx callback </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.23">(*m_pfnDisconnectCallBack)</A></B>(string &amp; sClient, void*  pParam)
<DD><I>user supplied OnDisconnect callback </I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.29">OnNewClient</A></B>(XPCTcpSocket*  pNewClient, char*  sName)
<DD><I>Called when a new client connects.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.30">ProcessClient</A></B>()
<DD><I>called from Server loop this function handles all the processing for the current client call.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>bool <B><A HREF="#DOC.4.34">StartThreads</A></B>()
<DD><I>called from init to start teh listen and server threads up</I>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="CMOOSCommObject.html">CMOOSCommObject</A>:</H3>
<DL>
<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>bool <B>SocketsInit</B>()
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>This class is the MOOS Comms Server. It lies at the heart of the communications
architecture and typically is of no interest to the component developer. It maintains a list of all
the connected clients and their names. It simultaneously listens on all sockets for calling clients
and then calls a user supplied call back to handle the request. This class is only used by the 
CMOOSDB application</BLOCKQUOTE>
<DL>

<A NAME="SetOnRxCallBack"></A>
<A NAME="DOC.4.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void SetOnRxCallBack(bool (*pfn)(MOOSMSG_LIST &amp; MsgListRx, MOOSMSG_LIST &amp; MsgListTx, void*  pParam), void*  pParam)</B></TT>
<DD>Set the recieve message call back handler. The callback will be called whenever
a client sends one or more messages to teh server. The supplied call back must be of the form
static bool MyCallBack(MOOSMSG_LIST &amp; RxLst,MOOSMSG_LIST &amp; TxLst, void * pParam). 

<DL><DT><DT><B>Parameters:</B><DD><B>RxLst</B> -     contains the incoming messages.
<BR><B>TxLst</B> -     passed to the handler as a recepticle for all the message that	should be sent back to the client in response to teh incoming messages.
<BR><B>pParam</B> - 	  user suplied parameter to be passed to callback function<BR><DD></DL><P>
<A NAME="SetOnDisconnectCallBack"></A>
<A NAME="DOC.4.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void SetOnDisconnectCallBack(bool (*pfn)(string &amp; sClient, void*  pParam), void*  pParam)</B></TT>
<DD>Set the disconnect message call back handler.  The supplied call back must be of the form
static bool MyCallBack(string &amp; sClient,, void * pParam). 

<DL><DT><DT><B>Parameters:</B><DD><B>sClient</B> -     contains the incoming messages.
<BR><B>TxLst</B> -     passed to the handler as a recepticle for all the message that	should be sent back to the client in response to teh incoming messages.
<BR><B>pParam</B> - 	  user suplied parameter to be passed to callback function<BR><DD></DL><P>
<A NAME="ListenLoop"></A>
<A NAME="DOC.4.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool ListenLoop()</B></TT>
<DD>This function is the listen loop called from one of the two server threads. It is responsible
for accepting a coonection and creating a new client socket.	
<DL><DT><DD></DL><P>
<A NAME="ServerLoop"></A>
<A NAME="DOC.4.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool ServerLoop()</B></TT>
<DD>This function is the server loop called from one of the two server threads. It listens to all presently connected
sockets and when a call is received invokes thse user supplied callback 
<DL><DT><DD></DL><P>
<A NAME="Run"></A>
<A NAME="DOC.4.5"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool Run(long lPort)</B></TT>
<DD>Initialise the server. This is a non blocking call and launches the MOOS Comms server threads. 

<DL><DT><DT><B>Parameters:</B><DD><B>lPort</B> -  port number to listen on<BR><DD></DL><P>
<A NAME="CMOOSCommServer"></A>
<A NAME="DOC.4.6"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> CMOOSCommServer()</B></TT>
<DD>default constructor
<DL><DT><DD></DL><P>
<A NAME="~CMOOSCommServer"></A>
<A NAME="DOC.4.7"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~CMOOSCommServer()</B></TT>
<DD>default destructor
<DL><DT><DD></DL><P>
<A NAME="m_SocketListLock"></A>
<A NAME="DOC.4.8"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="CMOOSLock.html">CMOOSLock</A> m_SocketListLock</B></TT>
<DD>a simple mutex to guard access to m_ClientSocketList

<DL><DT><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.27">m_ClientSocketList</A> <BR><DD></DL><P>
<A NAME="GetMaxSocketFD"></A>
<A NAME="DOC.4.9"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int GetMaxSocketFD()</B></TT>
<DD>figures out what the largest socket FD of all connected sockets. (needed by select)
<DL><DT><DD></DL><P>
<A NAME="DoBanner"></A>
<A NAME="DOC.4.10"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void DoBanner()</B></TT>
<DD>prints class information banner to cout 
<DL><DT><DD></DL><P>
<A NAME="GetClientName"></A>
<A NAME="DOC.4.11"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>string GetClientName(XPCTcpSocket* pSocket)</B></TT>
<DD>Get the name of the client on the remote end of pSocket
<DL><DT><DD></DL><P>
<A NAME="PoisonClient"></A>
<A NAME="DOC.4.12"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void PoisonClient(XPCTcpSocket* pSocket, char*  sReason)</B></TT>
<DD>Send a Poisoned mesasge to the client on the end of pSocket. This may cause teh client
comms thrad to die 
<DL><DT><DD></DL><P>
<A NAME="HandShake"></A>
<A NAME="DOC.4.13"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool HandShake(XPCTcpSocket* pNewSocket)</B></TT>
<DD>Perform handshaling with client just after a connection has been accepted 
<DL><DT><DD></DL><P>
<A NAME="IsUniqueName"></A>
<A NAME="DOC.4.14"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool IsUniqueName(string &amp; sClientName)</B></TT>
<DD>returns true if a server has no connection to the named client

<DL><DT><DT><B>Parameters:</B><DD><B>sClientName</B> -  reference to client name string<BR><DD></DL><P>
<A NAME="m_nTotalActions"></A>
<A NAME="DOC.4.15"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int m_nTotalActions</B></TT>
<DD>internal count of the number of calls processed
<DL><DT><DD></DL><P>
<A NAME="OnClientDisconnect"></A>
<A NAME="DOC.4.16"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool OnClientDisconnect()</B></TT>
<DD>called when a client disconnects or and error occurs
<DL><DT><DD></DL><P>
<A NAME="m_hListenThread"></A>
<A NAME="DOC.4.17"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>HANDLE m_hListenThread</B></TT>
<DD>Win32 handle to Listen thread 

<DL><DT><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.3">ListenLoop</A><BR><DD></DL><P>
<A NAME="m_hServerThread"></A>
<A NAME="DOC.4.18"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>HANDLE m_hServerThread</B></TT>
<DD>Win32 handle to Server thread 

<DL><DT><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.4">ServerLoop</A><BR><DD></DL><P>
<A NAME="m_nListenThreadID"></A>
<A NAME="DOC.4.19"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned long m_nListenThreadID</B></TT>
<DD>ID of Listen Thread
<DL><DT><DD></DL><P>
<A NAME="m_nServerThreadID"></A>
<A NAME="DOC.4.20"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned long m_nServerThreadID</B></TT>
<DD>ID of Server Thread
<DL><DT><DD></DL><P>
<A NAME="(*m_pfnRxCallBack)"></A>
<A NAME="DOC.4.21"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool (*m_pfnRxCallBack)(MOOSMSG_LIST &amp; MsgListRx, MOOSMSG_LIST &amp; MsgListTx, void*  pCaller)</B></TT>
<DD>user supplied OnRx callback

<DL><DT><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.1">SetOnRxCallBack</A> <BR><DD></DL><P>
<A NAME="m_pRxCallBackParam"></A>
<A NAME="DOC.4.22"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void* m_pRxCallBackParam</B></TT>
<DD>place holder for teh address of the object passed back to the user during an Rx callback

<DL><DT><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.1">SetOnRxCallBack</A> <BR><DD></DL><P>
<A NAME="(*m_pfnDisconnectCallBack)"></A>
<A NAME="DOC.4.23"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool (*m_pfnDisconnectCallBack)(string &amp; sClient, void*  pParam)</B></TT>
<DD>user supplied OnDisconnect callback

<DL><DT><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.2">SetOnDisconnectCallBack</A> <BR><DD></DL><P>
<A NAME="m_pDisconnectCallBackParam"></A>
<A NAME="DOC.4.24"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void* m_pDisconnectCallBackParam</B></TT>
<DD>place holder for teh address of the object passed back to the user during a Disconnect callback

<DL><DT><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.2">SetOnDisconnectCallBack</A> <BR><DD></DL><P>
<A NAME="m_pListenSocket"></A>
<A NAME="DOC.4.25"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>XPCTcpSocket* m_pListenSocket</B></TT>
<DD>Listen socket (bound to port address supplied in constructor) 
<DL><DT><DD></DL><P>
<A NAME="m_pFocusSocket"></A>
<A NAME="DOC.4.26"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>XPCTcpSocket* m_pFocusSocket</B></TT>
<DD>pointer to the socket which server is currently processing call from 
<DL><DT><DD></DL><P>
<A NAME="m_ClientSocketList"></A>
<A NAME="DOC.4.27"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>SOCKETLIST m_ClientSocketList</B></TT>
<DD>list of all currently connected sockets 
<DL><DT><DD></DL><P>
<A NAME="m_Socket2ClientMap"></A>
<A NAME="DOC.4.28"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>SOCKETFD_2_CLIENT_NAME_MAP m_Socket2ClientMap</B></TT>
<DD>map of socket file descriptors to the string name of the client process at teh other end
<DL><DT><DD></DL><P>
<A NAME="OnNewClient"></A>
<A NAME="DOC.4.29"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool OnNewClient(XPCTcpSocket*  pNewClient, char*  sName)</B></TT>
<DD>Called when a new client connects. Performs handshaking and adds new socket to m_ClientSocketList

<DL><DT><DT><B>Parameters:</B><DD><B>pNewClient</B> -  pointer to teh new socket created in <!1><A HREF="CMOOSCommServer.html#DOC.4.3">ListenLoop</A>;
<BR><DT><B>See Also:</B><DD><!1><A HREF="CMOOSCommServer.html#DOC.4.3">ListenLoop</A><BR><DD></DL><P>
<A NAME="ProcessClient"></A>
<A NAME="DOC.4.30"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool ProcessClient()</B></TT>
<DD>called from Server loop this function handles all the processing for the current client call. It inturn
invokes the user supplied callback function 
<DL><DT><DD></DL><P>
<A NAME="m_lListenPort"></A>
<A NAME="DOC.4.31"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>long m_lListenPort</B></TT>
<DD>port listen socket is bound to 
<DL><DT><DD></DL><P>
<A NAME="m_bQuit"></A>
<A NAME="DOC.4.32"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool m_bQuit</B></TT>
<DD>threads continue while this flag is false
<DL><DT><DD></DL><P>
<A NAME="m_nMaxSocketFD"></A>
<A NAME="DOC.4.33"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int m_nMaxSocketFD</B></TT>
<DD>largest FD of all connected sockets
<DL><DT><DD></DL><P>
<A NAME="StartThreads"></A>
<A NAME="DOC.4.34"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool StartThreads()</B></TT>
<DD>called from init to start teh listen and server threads up
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BODY>
<H4>
MOOSLib
&#169;  P. Newman 2001 <img src="moose2.gif">
</H4>
</BODY>
